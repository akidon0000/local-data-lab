//
//  InfiniteScrollViewLogic.swift
//  localDB-sampleer
//
//  Created by Akihiro Matsuyama on 2025/10/11.
//

import SwiftData
import SwiftUI

extension InfiniteScrollView {
    // MARK: - データ管理メソッド
    
    // 名刺を追加
    func addBusinessCard(
        name: String,
        company: String,
        position: String
    ) {
        guard !name.isEmpty && !company.isEmpty else { return }
        
        let newCard = BusinessCard(
            name: name,
            company: company,
            position: position
        )
        
        modelContext.insert(newCard)
        
        do {
            try modelContext.save()
            errorMessage = nil
        } catch {
            errorMessage = "名刺の保存に失敗しました: \(error.localizedDescription)"
        }
    }
    
    // 名刺を削除
    func deleteBusinessCard(_ card: BusinessCard) {
        modelContext.delete(card)
        
        do {
            try modelContext.save()
            errorMessage = nil
        } catch {
            errorMessage = "名刺の削除に失敗しました: \(error.localizedDescription)"
        }
    }
    
    // 全ての名刺を削除
    func deleteAllBusinessCards() {
        Task {
            await deleteAllBusinessCardsAsync()
        }
    }
    
    @MainActor
    private func deleteAllBusinessCardsAsync() async {
        isLoading = true
        errorMessage = nil
        
        do {
            // バッチサイズで分割して削除
            let batchSize = 100
            let descriptor = FetchDescriptor<BusinessCard>()
            
            while true {
                var limitedDescriptor = descriptor
                limitedDescriptor.fetchLimit = batchSize
                
                let cardsToDelete = try modelContext.fetch(limitedDescriptor)
                
                if cardsToDelete.isEmpty {
                    break
                }
                
                for card in cardsToDelete {
                    modelContext.delete(card)
                }
                
                try modelContext.save()
                
                // UIの応答性を保つため少し待機
                try await Task.sleep(nanoseconds: 10_000_000) // 0.01秒
            }
            
            isLoading = false
        } catch {
            errorMessage = "名刺の削除に失敗しました: \(error.localizedDescription)"
            isLoading = false
        }
    }
    
    // 指定件数の名刺を削除（最新から）
    func deleteBusinessCards(count: Int) {
        Task {
            await deleteBusinessCardsAsync(count: count)
        }
    }
    
    @MainActor
    private func deleteBusinessCardsAsync(count: Int) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let batchSize = 100
            var remainingCount = count
            
            while remainingCount > 0 {
                let currentBatchSize = min(batchSize, remainingCount)
                
                // 最新の名刺から削除
                var descriptor = FetchDescriptor<BusinessCard>(
                    sortBy: [SortDescriptor(\.name, order: .reverse)]
                )
                descriptor.fetchLimit = currentBatchSize
                
                let cardsToDelete = try modelContext.fetch(descriptor)
                
                if cardsToDelete.isEmpty {
                    break
                }
                
                for card in cardsToDelete {
                    modelContext.delete(card)
                }
                
                try modelContext.save()
                
                remainingCount -= cardsToDelete.count
                
                // UIの応答性を保つため少し待機
                if remainingCount > 0 {
                    try await Task.sleep(nanoseconds: 10_000_000) // 0.01秒
                }
            }
            
            isLoading = false
        } catch {
            errorMessage = "名刺の削除に失敗しました: \(error.localizedDescription)"
            isLoading = false
        }
    }
    
    // サンプルデータを生成
    func generateSampleData() {
        let sampleCards = [
            ("田中 太郎", "株式会社サンプル", "営業部長"),
            ("佐藤 花子", "テクノロジー株式会社", "エンジニア"),
            ("鈴木 一郎", "デザイン事務所", "デザイナー"),
            ("高橋 美咲", "マーケティング会社", "マネージャー"),
            ("山田 健太", "コンサルティング会社", "コンサルタント")
        ]
        
        for (name, company, position) in sampleCards {
            // 重複チェック
            let descriptor = FetchDescriptor<BusinessCard>(
                predicate: #Predicate { card in
                    card.name == name && card.company == company
                }
            )
            
            do {
                let existingCards = try modelContext.fetch(descriptor)
                if existingCards.isEmpty {
                    addBusinessCard(
                        name: name,
                        company: company,
                        position: position
                    )
                }
            } catch {
                print("サンプルデータの重複チェックに失敗: \(error)")
            }
        }
    }
    
    // 指定件数の名刺を一括追加
    func addBusinessCards(count: Int) {
        Task {
            await addBusinessCardsAsync(count: count)
        }
    }
    
    @MainActor
    private func addBusinessCardsAsync(count: Int) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let companies = getCompanies()
            let positions = getPositions()
            let firstNames = getFirstNames()
            let lastNames = getLastNames()
            
            // バッチ処理でパフォーマンスを向上
            let batchSize = 100
            let batches = (count + batchSize - 1) / batchSize
            
            for batch in 0..<batches {
                let startIndex = batch * batchSize
                let endIndex = min(startIndex + batchSize, count)
                let currentBatchSize = endIndex - startIndex
                
                // バックグラウンドでデータ生成
                let newCards = await Task.detached {
                    var cards: [BusinessCard] = []
                    for _ in 0..<currentBatchSize {
                        let lastName = lastNames.randomElement()!
                        let firstName = firstNames.randomElement()!
                        let company = companies.randomElement()!
                        let position = positions.randomElement()!
                        
                        let newCard = BusinessCard(
                            name: "\(lastName) \(firstName)",
                            company: company,
                            position: position
                        )
                        cards.append(newCard)
                    }
                    return cards
                }.value
                
                // メインアクターでデータベースに保存
                for card in newCards {
                    modelContext.insert(card)
                }
                
                try modelContext.save()
                
                // 少し待機してUIの応答性を保つ
                if batch < batches - 1 {
                    try await Task.sleep(nanoseconds: 10_000_000) // 0.01秒
                }
            }
            
            isLoading = false
        } catch {
            errorMessage = "名刺の保存に失敗しました: \(error.localizedDescription)"
            isLoading = false
        }
    }
    
    // 大量のサンプルデータを生成（無限スクロールのテスト用）
    func generateLargeSampleData() {
        addBusinessCards(count: 500)
    }
    
    // 会社名の配列を取得
    private func getCompanies() -> [String] {
        return [
            // IT・テクノロジー系
            "株式会社テクノロジー", "システム開発株式会社", "ソフトウェア株式会社", "IT株式会社", "デジタル株式会社",
            "株式会社イノベーション", "株式会社フューチャー", "株式会社アドバンス", "株式会社プログレス", "株式会社サクセス",
            "クラウド株式会社", "データ株式会社", "AI株式会社", "IoT株式会社", "ブロックチェーン株式会社",
            "サイバー株式会社", "ネット株式会社", "ウェブ株式会社", "モバイル株式会社", "アプリ株式会社",
            
            // コンサルティング・サービス系
            "コンサルティング株式会社", "ビジネス株式会社", "マネジメント株式会社", "ストラテジー株式会社", "アドバイザリー株式会社",
            "プロフェッショナル株式会社", "エキスパート株式会社", "スペシャリスト株式会社", "コンサル株式会社", "アナリスト株式会社",
            "リサーチ株式会社", "調査株式会社", "分析株式会社", "企画株式会社", "戦略株式会社",
            
            // マーケティング・広告系
            "マーケティング株式会社", "広告株式会社", "宣伝株式会社", "PR株式会社", "ブランディング株式会社",
            "クリエイティブ株式会社", "デザイン株式会社", "アート株式会社", "制作株式会社", "企画制作株式会社",
            "メディア株式会社", "コンテンツ株式会社", "エンターテイメント株式会社", "映像株式会社", "音響株式会社",
            
            // 製造・工業系
            "製造株式会社", "工業株式会社", "機械株式会社", "電機株式会社", "電子株式会社",
            "精密株式会社", "技術株式会社", "エンジニアリング株式会社", "開発株式会社", "研究株式会社",
            "化学株式会社", "材料株式会社", "素材株式会社", "金属株式会社", "プラスチック株式会社",
            
            // 金融・保険系
            "金融株式会社", "銀行株式会社", "証券株式会社", "保険株式会社", "投資株式会社",
            "ファイナンス株式会社", "資産運用株式会社", "信託株式会社", "リース株式会社", "クレジット株式会社",
            "決済株式会社", "フィンテック株式会社", "暗号資産株式会社", "投資顧問株式会社", "資産管理株式会社",
            
            // 小売・流通系
            "小売株式会社", "流通株式会社", "商社株式会社", "貿易株式会社", "輸出入株式会社",
            "卸売株式会社", "販売株式会社", "営業株式会社", "マーチャンダイジング株式会社", "リテール株式会社",
            "EC株式会社", "オンライン株式会社", "通販株式会社", "Eコマース株式会社", "ショッピング株式会社",
            
            // 不動産・建設系
            "不動産株式会社", "建設株式会社", "建築株式会社", "設計株式会社", "施工株式会社",
            "住宅株式会社", "マンション株式会社", "オフィス株式会社", "商業施設株式会社", "土地開発株式会社",
            "都市開発株式会社", "再開発株式会社", "リノベーション株式会社", "インテリア株式会社", "家具株式会社",
            
            // 医療・ヘルスケア系
            "医療株式会社", "ヘルスケア株式会社", "製薬株式会社", "バイオ株式会社", "医療機器株式会社",
            "病院株式会社", "クリニック株式会社", "診療所株式会社", "介護株式会社", "福祉株式会社",
            "健康株式会社", "ウェルネス株式会社", "フィットネス株式会社", "スポーツ株式会社", "栄養株式会社",
            
            // 教育・人材系
            "教育株式会社", "学習株式会社", "研修株式会社", "人材株式会社", "人事株式会社",
            "採用株式会社", "転職株式会社", "キャリア株式会社", "スキル株式会社", "能力開発株式会社",
            "トレーニング株式会社", "コーチング株式会社", "メンタリング株式会社", "カウンセリング株式会社", "サポート株式会社",
            
            // 運輸・物流系
            "運輸株式会社", "物流株式会社", "配送株式会社", "宅配株式会社", "輸送株式会社",
            "倉庫株式会社", "保管株式会社", "ロジスティクス株式会社", "サプライチェーン株式会社", "流通株式会社",
            "航空株式会社", "海運株式会社", "陸運株式会社", "鉄道株式会社", "バス株式会社"
        ]
    }
    
    // 役職の配列を取得
    private func getPositions() -> [String] {
        return [
            // 経営層
            "代表取締役", "取締役", "執行役員", "常務取締役", "専務取締役", "副社長", "社長", "会長", "CEO", "CTO",
            "CFO", "COO", "CIO", "CMO", "CHRO", "CDO", "CPO", "CSO", "CCO", "CRO",
            
            // 管理職
            "部長", "副部長", "課長", "副課長", "係長", "主任", "班長", "グループ長", "チーフ", "リーダー",
            "マネージャー", "シニアマネージャー", "ゼネラルマネージャー", "エリアマネージャー", "ブランチマネージャー",
            "プロダクトマネージャー", "プロジェクトマネージャー", "プログラムマネージャー", "オペレーションマネージャー", "セールスマネージャー",
            
            // 技術職
            "エンジニア", "シニアエンジニア", "リードエンジニア", "プリンシパルエンジニア", "アーキテクト", "テックリード",
            "フロントエンドエンジニア", "バックエンドエンジニア", "フルスタックエンジニア", "インフラエンジニア", "DevOpsエンジニア",
            "データエンジニア", "MLエンジニア", "AIエンジニア", "セキュリティエンジニア", "QAエンジニア",
            "システムエンジニア", "ネットワークエンジニア", "データベースエンジニア", "クラウドエンジニア", "モバイルエンジニア",
            
            // デザイン職
            "デザイナー", "シニアデザイナー", "リードデザイナー", "アートディレクター", "クリエイティブディレクター",
            "UIデザイナー", "UXデザイナー", "UI/UXデザイナー", "プロダクトデザイナー", "グラフィックデザイナー",
            "ウェブデザイナー", "モーションデザイナー", "3Dデザイナー", "イラストレーター", "フォトグラファー",
            
            // 営業・マーケティング職
            "営業", "シニア営業", "営業主任", "営業課長", "営業部長", "セールス", "アカウントマネージャー",
            "インサイドセールス", "フィールドセールス", "カスタマーサクセス", "ビジネスデベロップメント", "パートナーセールス",
            "マーケティング", "マーケター", "デジタルマーケター", "コンテンツマーケター", "プロダクトマーケター",
            "ブランドマネージャー", "PR", "広報", "宣伝", "イベントプランナー",
            
            // 専門職・コンサルタント
            "コンサルタント", "シニアコンサルタント", "プリンシパルコンサルタント", "パートナー", "アソシエイト",
            "アナリスト", "シニアアナリスト", "リサーチャー", "データアナリスト", "ビジネスアナリスト",
            "スペシャリスト", "エキスパート", "アドバイザー", "エバンジェリスト", "コンサルティングディレクター",
            
            // 人事・総務・経理
            "人事", "人事部長", "採用担当", "労務担当", "研修担当", "人材開発", "組織開発",
            "総務", "総務部長", "法務", "知的財産", "コンプライアンス", "内部監査", "リスク管理",
            "経理", "財務", "会計", "経営企画", "事業企画", "戦略企画", "IR",
            
            // カスタマーサポート・サービス
            "カスタマーサポート", "テクニカルサポート", "ヘルプデスク", "フィールドサービス", "カスタマーサービス",
            "サポートエンジニア", "プリセールス", "ポストセールス", "トレーナー", "インストラクター",
            
            // 製造・品質管理
            "製造", "生産管理", "品質管理", "品質保証", "製造技術", "生産技術", "工程管理",
            "検査", "試験", "評価", "改善", "保守", "メンテナンス", "設備管理",
            
            // その他専門職
            "研究員", "開発", "企画", "編集", "ライター", "翻訳", "通訳", "講師",
            "医師", "看護師", "薬剤師", "理学療法士", "作業療法士", "栄養士", "介護士"
        ]
    }
    
    // 名前の配列を取得
    private func getFirstNames() -> [String] {
        return [
            // 伝統的な男性名
            "太郎", "一郎", "健太", "大輔", "翔太", "裕太", "直樹", "雅人", "博之", "隆",
            "修", "浩", "誠", "剛", "学", "明", "勇", "進", "豊", "正",
            "和也", "拓也", "哲也", "達也", "雄也", "秀也", "克也", "智也", "淳也", "慎也",
            "慎一", "康一", "洋一", "昭一", "健一", "良一", "信一", "義一", "敏一", "光一",
            "武", "勝", "強", "猛", "剛", "豪", "勇", "雄", "英", "俊",
            
            // 伝統的な女性名
            "花子", "美咲", "由美", "恵子", "麻衣", "美香", "智子", "真理", "加奈", "綾子",
            "典子", "理恵", "千春", "美穂", "純子", "香織", "奈美", "幸子", "陽子", "洋子",
            "美樹", "美紀", "美貴", "美希", "美季", "美喜", "美輝", "美記", "美規", "美基",
            "愛", "恵", "恵美", "恵子", "恵里", "恵理", "恵利", "恵梨", "恵莉", "恵璃",
            "優", "優子", "優美", "優香", "優花", "優華", "優佳", "優加", "優果", "優夏",
            
            // 現代的な男性名
            "翔", "蓮", "大翔", "陽翔", "結翔", "悠翔", "颯", "颯太", "颯人", "颯真",
            "陽", "陽太", "陽人", "陽斗", "陽向", "陽翔", "陽大", "陽介", "陽平", "陽一",
            "蒼", "蒼太", "蒼人", "蒼斗", "蒼空", "蒼真", "蒼介", "蒼平", "蒼一", "蒼大",
            "悠", "悠太", "悠人", "悠斗", "悠真", "悠介", "悠平", "悠一", "悠大", "悠希",
            "湊", "湊太", "湊人", "湊斗", "湊真", "湊介", "湊平", "湊一", "湊大", "湊希",
            
            // 現代的な女性名
            "結", "結愛", "結菜", "結衣", "結花", "結華", "結香", "結佳", "結加", "結果",
            "咲", "咲良", "咲希", "咲子", "咲美", "咲恵", "咲織", "咲音", "咲月", "咲空",
            "美", "美月", "美空", "美桜", "美花", "美華", "美香", "美佳", "美加", "美果",
            "愛", "愛美", "愛子", "愛花", "愛華", "愛香", "愛佳", "愛加", "愛果", "愛夏",
            "心", "心愛", "心美", "心花", "心華", "心香", "心佳", "心加", "心果", "心夏",
            
            // 季節・自然由来の名前
            "春", "春香", "春花", "春華", "春佳", "春加", "春果", "春夏", "春美", "春子",
            "夏", "夏美", "夏子", "夏花", "夏華", "夏香", "夏佳", "夏加", "夏果", "夏希",
            "秋", "秋美", "秋子", "秋花", "秋華", "秋香", "秋佳", "秋加", "秋果", "秋希",
            "冬", "冬美", "冬子", "冬花", "冬華", "冬香", "冬佳", "冬加", "冬果", "冬希",
            "桜", "桜子", "桜花", "桜華", "桜香", "桜佳", "桜加", "桜果", "桜希", "桜美",
            
            // 色彩由来の名前
            "青", "青空", "青葉", "青山", "青海", "青木", "青田", "青野", "青原", "青川",
            "赤", "赤音", "赤花", "赤葉", "赤山", "赤海", "赤木", "赤田", "赤野", "赤原",
            "白", "白雪", "白花", "白葉", "白山", "白海", "白木", "白田", "白野", "白原",
            "黒", "黒木", "黒田", "黒山", "黒海", "黒川", "黒野", "黒原", "黒石", "黒沢",
            "緑", "緑花", "緑葉", "緑山", "緑海", "緑木", "緑田", "緑野", "緑原", "緑川"
        ]
    }
    
    // 苗字の配列を取得
    private func getLastNames() -> [String] {
        return [
            // 一般的な苗字（上位100位）
            "田中", "佐藤", "鈴木", "高橋", "山田", "渡辺", "伊藤", "中村", "小林", "加藤",
            "吉田", "山本", "松本", "井上", "木村", "林", "斎藤", "清水", "山崎", "森",
            "池田", "橋本", "山口", "石川", "中島", "前田", "藤田", "後藤", "岡田", "長谷川",
            "村上", "近藤", "石田", "遠藤", "青木", "坂本", "福田", "太田", "西村", "藤井",
            "岡本", "松田", "中川", "中野", "原田", "小川", "竹内", "和田", "中山", "石井",
            "上田", "森田", "原", "柴田", "酒井", "工藤", "横山", "宮崎", "宮本", "内田",
            "高木", "安藤", "島田", "谷口", "大野", "高田", "丸山", "今井", "河野", "藤原",
            "小野", "田村", "吉川", "五十嵐", "三浦", "白石", "関", "杉山", "大塚", "平野",
            "菅原", "武田", "新井", "小島", "南", "千葉", "大西", "岩田", "松井", "菊地",
            "野口", "木下", "佐々木", "野村", "松尾", "菅野", "佐野", "山下", "大橋", "杉本",
            
            // 地域性のある苗字
            "小松", "小山", "大山", "川口", "金子", "片山", "宮田", "長井", "西川", "古川",
            "水野", "永田", "川崎", "秋山", "本田", "村田", "沢田", "星野", "小池", "田口",
            "阿部", "石原", "松村", "飯田", "細川", "山内", "黒田", "服部", "海老原", "大久保",
            "岸本", "増田", "小泉", "今村", "川村", "田島", "吉岡", "望月", "金田", "平田",
            "島村", "川上", "菊池", "土屋", "市川", "大島", "柳", "矢野", "岩崎", "桜井",
            
            // 特徴的な苗字
            "富田", "野田", "渡部", "上野", "菅", "大谷", "石橋", "新田", "小野寺", "森本",
            "三宅", "岡崎", "金井", "田代", "久保", "栗原", "荒木", "横田", "内藤", "江口",
            "大森", "田辺", "福島", "岡", "荒井", "中田", "飯塚", "古田", "中西", "水田",
            "堀", "宇野", "杉田", "谷", "尾崎", "河合", "松岡", "古賀", "北村", "山岡",
            "浜田", "篠原", "岩本", "松原", "中原", "大石", "植田", "坂田", "神田", "西田",
            
            // 複合苗字・珍しい苗字
            "西山", "川島", "小西", "森川", "平井", "柳田", "堀内", "小田", "安田", "三好",
            "川端", "岩井", "長田", "桑原", "福本", "中井", "石崎", "浅野", "大内", "森岡",
            "高山", "中沢", "井口", "松下", "高野", "小沢", "浜口", "池上", "森下", "長野",
            "石山", "小倉", "大川", "野沢", "吉村", "福井", "西野", "古屋", "小原", "山村",
            "大沢", "佐川", "西岡", "田畑", "松永", "大竹", "小菅", "野上", "河田", "中尾",
            
            // 追加の多様な苗字
            "小笠原", "松島", "大友", "竹田", "本間", "須藤", "相田", "木田", "小田切", "大沼",
            "榎本", "宮下", "富樫", "大場", "小柳", "大井", "小島田", "大河原", "小野田", "竹村",
            "花田", "草野", "竹本", "柿沼", "梅田", "桃井", "桜田", "松葉", "杉原", "檜山",
            "椎名", "楠本", "柏木", "橘", "藤沢", "藤野", "藤岡", "藤山", "藤川", "藤森",
            "春日", "夏目", "秋田", "冬木", "朝倉", "夕田", "東", "西", "南野", "北川",
            
            // 職業・地形由来の苗字
            "鍛冶", "大工", "漁師", "農夫", "商人", "武士", "僧侶", "医師", "教師", "画家",
            "山田", "川田", "海田", "森田", "野田", "池田", "沼田", "湖田", "谷田", "峰田",
            "石田", "岩田", "砂田", "土田", "金田", "銀田", "鉄田", "銅田", "玉田", "珠田",
            "花岡", "桜岡", "梅岡", "松岡", "竹岡", "杉岡", "柳岡", "桐岡", "楓岡", "椿岡",
            "青山", "赤山", "白山", "黒山", "緑山", "紫山", "黄山", "茶山", "灰山", "銀山"
        ]
    }
}
